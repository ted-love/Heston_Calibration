# Heston_Calibation

Heston_Calibration.py calibrates the Heston Model using the Levenberg-Marquardt algoithm with COS-expansion calculation for the Heston model. Running the file will use pre-loaded historial data. The prices are transformed into implied volatilities and the heston is calibrated against the market implied vols. Dividend rates calculated from creating an implied forward-rate curve, and historical data is use dfor initial guesses. The 2nd iteration of the for loop uses a pre-calibration that runs on a smaller data set with a large damping factor. The results of the pre-calibration is used as the initial guesses to calibrate on the whole data set with a reduced damping factor. Similarly to conclusions in the literauture, the heston model struggles to price short dte options because it struggles to capture the implied vol smirk. Generally calibrate to data > 50-day expiries. 

tools/Heston_COS_METHOD.py is a vectorised method of calculating European options for the heston model using cosine expansion. It is a robust method for fast Heston calculation and takes the cosine expansion of the whole integral of the fourier transform. It is vectorised along the different options AND vectorised along the summation. It is 300x faster than QuantLib's Python implementation FFT of the Heston, because we can truncate and use far less terms to converge (Typically only 64-100 terms vs 1,000 terms) 

tools/Levenberg_Marquardt.py is my own implementation of a box-constrained Levenbrg-Marquardt Algorithm for calibrating the Heston model, and can calibrate all 5 parameters of the heston model. It converts the prices to implied volatilities and calibrated to implied volatilities. The damping factor is reduced based on the gain factor. Thus, the damping factor could still increase even if the step is accepted if the gain factor is too small. Using the gain factor to change in the damping facto is better than the tradition multiply/divide by 10 method as it results in far fewer rejected steps. To constrain the parameters, if the new parameter would exceed a bound, the new parameter value becomes the mid point of the old parameter and boundary value. 
